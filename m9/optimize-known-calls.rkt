#lang racket

(require
  cpsc411/compiler-lib
  cpsc411/langs/v9)

(provide optimize-known-calls)

;; Milestone 9 Exercise 10
;;
;; Optimizes calls to known closures
(define/contract (optimize-known-calls p)
  (-> closure-lang-v9? closure-lang-v9?)

  ;; closure-lang-v9-p -> closure-lang-v9-p
  ;; Optimizes closure-calls to call in p if known
  (define (optimize-known-calls-p p)
    (match p
      [`(module ,value)
       `(module ,(optimize-known-calls-value value '()))]))

  ;; closure-lang-v9-value dict(aloc, label) -> closure-lang-v9-value
  ;; Optimize closure-calls to calls in v using dictionary of known closures
  (define (optimize-known-calls-value v known)
    (match v
      [`(closure-ref ,vc ,vv)
       `(closure-ref
          ,(optimize-known-calls-value vc known)
          ,(optimize-known-calls-value vv known))]
      [`(closure-call ,vc ,vs ...)
        (define new-vs (for/list ([v vs]) (optimize-known-calls-value v known)))
        (if (and (aloc? vc) (dict-has-key? known vc))
            `(call ,(dict-ref known vc) ,@new-vs)
            `(closure-call
               ,(optimize-known-calls-value vc known)
               ,@new-vs))]
      [`(call ,vc ,vs ...)
       `(call
          ,(optimize-known-calls-value vc known)
          ,@(for/list ([v vs]) (optimize-known-calls-value v known)))]
      [`(letrec ([,labels (lambda (,params ...) ,vs)] ...) ,vt)
       (optimize-known-calls-letrec labels params vs vt known)]
      [`(cletrec ([,alocs (make-closure ,labels ,vss ...)] ...) ,vt)
       (define aloc-closure-pairs
         (for/list ([aloc alocs] [label labels] [vs vss])
           (define new-vs (for/list ([v vs]) (optimize-known-calls-value v known)))
           `(,aloc (make-closure ,label ,@new-vs))))
       `(cletrec
          ,aloc-closure-pairs
          ,(optimize-known-calls-value vt known))]
      [`(let ([,alocs ,vs] ...) ,vt)
       (define new-aloc-vs
         (for/list ([aloc alocs] [v vs])
           `[,aloc ,(optimize-known-calls-value v known)]))
       `(let
          ,new-aloc-vs
          ,(optimize-known-calls-value vt known))]
      [`(if ,vp ,vt ,vf)
       `(if
          ,(optimize-known-calls-value vp known)
          ,(optimize-known-calls-value vt known)
          ,(optimize-known-calls-value vf known))]
      [`(begin ,effects ... ,value)
       (define new-es
         (for/list ([effect effects])
           (optimize-known-calls-effect effect known)))
       `(begin
          ,@new-es
          ,(optimize-known-calls-value value known))]
      [`(,primop ,vs ...)
       #:when (primop? primop)
       (define new-vs
         (for/list ([v vs])
           (optimize-known-calls-value v known)))
       `(,primop ,@new-vs)]
      [triv triv]))

  ;; (listof label) (listof (listof aloc)) (listof value) value dict(aloc, label)
  ;; -> closure-lang-v9-letrec
  ;;
  ;; If letrec is of the form:
  ;; `(letrec ([label_c (lambda (aloc ...) value_1)] ...)
  ;;    (cletrec ([aloc_c (make-closure label_c value_2 ...)] ...)
  ;;      value_3))
  ;; Add mappings from any aloc_c to label_c, and any (closure-call aloc_c ...)
  ;; in value_1 and value_3 will be converted to (call label_c ...).
  ;; Return the converted letrec value.
  ;; Assume that aloc_c isn't overriden by lets in value_1 or value_3
  ;; since these structures are generated by convert-closures.
  (define (optimize-known-calls-letrec labels params vs vt known)
    ;; dict(aloc, label) -> closure-lang-v9-letrec
    ;; Create letrec from known calls dictionary
    (define (create-letrec new-known)
      (define label-lambda-pairs
         (for/list ([label labels] [ps params] [v vs])
           `(,label (lambda ,ps ,(optimize-known-calls-value v new-known)))))
      `(letrec
         ,label-lambda-pairs
         ,(optimize-known-calls-value vt new-known)))
    (match vt
      [`(cletrec ([,calocs (make-closure ,clabels ,cvss ...)] ...) ,cvt)
       (define new-known
         (for/fold ([k known]) ([clabel clabels] [caloc calocs])
           (if (set-member? labels clabel)
               (dict-set k caloc clabel)
               k)))
       (create-letrec new-known)]
      ;; For templates:
      ;; triv
      ;; (primop value ...)
      ;; (closure-ref value value)
      ;; (closure-call value value ...)
      ;; (call value value ...)
      ;; (letrec ([label (lambda (aloc ...) value)] ...) value)
      ;; (cletrec ([aloc (make-closure label value ...)] ...) value)
      ;; (let ([aloc value] ...) value)
      ;; (if value value value)
      ;; (begin effect ... value)
      [_ (create-letrec known)]))

  ;; closure-lang-v9-effect dict(aloc, label) -> closure-lang-v9-effect
  ;; Optimize closure-calls to calls in e using dictionary of known closures
  (define (optimize-known-calls-effect e known)
    (match e
      [`(begin ,effects ... ,effect-t)
       `(begin
          ,@(for/list ([e effects]) (optimize-known-calls-effect e known))
          ,(optimize-known-calls-effect effect-t known))]
      [`(,primop ,vs ...)
       `(,primop
         ,@(for/list ([v vs]) (optimize-known-calls-value v known)))]))

  ;; Check that p is a primop
  (define/contract (primop? p)
    (-> any/c boolean?)
    (and (memq p
               '(unsafe-fx*
                 unsafe-fx+
                 unsafe-fx-
                 eq?
                 unsafe-fx<
                 unsafe-fx<=
                 unsafe-fx>
                 unsafe-fx>=
                 fixnum?
                 boolean?
                 empty?
                 void?
                 ascii-char?
                 error?
                 not
                 pair?
                 vector?
                 procedure?
                 cons
                 unsafe-car
                 unsafe-cdr
                 unsafe-make-vector
                 unsafe-vector-length
                 unsafe-vector-set!
                 unsafe-vector-ref
                 unsafe-procedure-arity))
         #t))

  ;; Removed template for triv

  (optimize-known-calls-p p))

(module+ test
  (require rackunit)

  ;; p -> void
  ;; Check that compiled program is the same as the original
  (define-check (check-no-change p)
    (check-equal?
      (optimize-known-calls p)
      p))

  ;; p p -> void
  ;; Check that compiled program is the same as expected
  ;; and interprets the same as the original
  (define-check (check-interp-expected p expected)
    (define compiled (optimize-known-calls p))
    (check-equal? compiled expected)
    (check-equal?
      (interp-closure-lang-v9 compiled)
      (interp-closure-lang-v9 p)))

  ;; p -> void
  ;; Check that compiled program interprets to the same value
  ;; as the original
  (define-check (check-interp p)
    (define compiled (optimize-known-calls p))
    (check-equal?
      (interp-closure-lang-v9 compiled)
      (interp-closure-lang-v9 p)))

  ;; base cases
  (check-no-change `(module 20))
  (check-no-change `(module (let ([x.1 2]) (unsafe-fx+ x.1 x.1))))

  ;; existing call
  (check-no-change
    `(module
       (letrec ([L.fn.1 (lambda (c.1 a.1) (unsafe-fx+ a.1 a.1))])
         (cletrec ([x.1 (make-closure L.fn.1 1)])
           (call L.fn.1 x.1 6)))))

  ;; basic - 1 param
  (check-interp-expected
    `(module
       (letrec ([L.fn.1 (lambda (c.1 a.1) (unsafe-fx+ a.1 a.1))])
         (cletrec ([x.1 (make-closure L.fn.1 1)])
           (closure-call x.1 x.1 6))))
    `(module
       (letrec ([L.fn.1 (lambda (c.1 a.1) (unsafe-fx+ a.1 a.1))])
         (cletrec ([x.1 (make-closure L.fn.1 1)])
           (call L.fn.1 x.1 6)))))

  ;; basic recursive - 1 param & 1 free
  (check-interp-expected
    `(module
      (let ([b.1 1])
        (letrec ([L.x.1.7
                  (lambda (c.4 a.1)
                    (let ([x.1 (closure-ref c.4 0)]
                          [b.1 (closure-ref c.4 1)])
                      (if (unsafe-fx<= a.1 0)
                        1
                        (unsafe-fx*
                          a.1
                          (closure-call x.1 x.1 (unsafe-fx- a.1 b.1))))))])
          (cletrec ([x.1 (make-closure L.x.1.7 1 x.1 b.1)])
            (closure-call x.1 x.1 6)))))
    `(module
      (let ([b.1 1])
        (letrec ([L.x.1.7
                  (lambda (c.4 a.1)
                    (let ([x.1 (closure-ref c.4 0)]
                          [b.1 (closure-ref c.4 1)])
                      (if (unsafe-fx<= a.1 0)
                        1
                        (unsafe-fx*
                          a.1
                          (call L.x.1.7 x.1 (unsafe-fx- a.1 b.1))))))])
          (cletrec ([x.1 (make-closure L.x.1.7 1 x.1 b.1)])
            (call L.x.1.7 x.1 6))))))

  ;; multiple in letrec
  (check-interp-expected
    `(module
      (let ([a.1 5] [b.1 8] [c.1 9])
        (letrec ([L.fn.0.1 (lambda (c.1) (let ((a.1 (closure-ref c.1 0))) a.1))]
                 [L.fn.1.2
                  (lambda (c.2 x.1 y.1)
                    (let ([c.1 (closure-ref c.2 0)]
                          [b.1 (closure-ref c.2 1)])
                      (unsafe-fx- c.1 (unsafe-fx+ x.1 (unsafe-fx* y.1 b.1)))))]
                 [L.fn.2.3
                  (lambda (c.3 x.1 y.1 z.1)
                    (let ([fn.0 (closure-ref c.3 0)]
                          [fn.1 (closure-ref c.3 1)]
                          [c.1 (closure-ref c.3 2)])
                      (unsafe-fx*
                        (unsafe-fx+ c.1 (unsafe-fx* x.1 (closure-call fn.0 fn.0)))
                        (closure-call fn.1 fn.1 y.1 z.1))))])
          (cletrec ([fn.0 (make-closure L.fn.0.1 0 a.1)]
                    [fn.1 (make-closure L.fn.1.2 2 c.1 b.1)]
                    [fn.2 (make-closure L.fn.2.3 3 fn.0 fn.1 c.1)])
            (unsafe-fx-
              (closure-call fn.0 fn.0)
              (unsafe-fx-
                (closure-call fn.1 fn.1 3 -4)
                (closure-call fn.2 fn.2 17 31 5)))))))
    `(module
      (let ([a.1 5] [b.1 8] [c.1 9])
        (letrec ([L.fn.0.1 (lambda (c.1) (let ((a.1 (closure-ref c.1 0))) a.1))]
                 [L.fn.1.2
                  (lambda (c.2 x.1 y.1)
                    (let ([c.1 (closure-ref c.2 0)]
                          [b.1 (closure-ref c.2 1)])
                      (unsafe-fx- c.1 (unsafe-fx+ x.1 (unsafe-fx* y.1 b.1)))))]
                 [L.fn.2.3
                  (lambda (c.3 x.1 y.1 z.1)
                    (let ([fn.0 (closure-ref c.3 0)]
                          [fn.1 (closure-ref c.3 1)]
                          [c.1 (closure-ref c.3 2)])
                      (unsafe-fx*
                        (unsafe-fx+ c.1 (unsafe-fx* x.1 (call L.fn.0.1 fn.0)))
                        (call L.fn.1.2 fn.1 y.1 z.1))))])
          (cletrec ([fn.0 (make-closure L.fn.0.1 0 a.1)]
                    [fn.1 (make-closure L.fn.1.2 2 c.1 b.1)]
                    [fn.2 (make-closure L.fn.2.3 3 fn.0 fn.1 c.1)])
            (unsafe-fx-
              (call L.fn.0.1 fn.0)
              (unsafe-fx-
                (call L.fn.1.2 fn.1 3 -4)
                (call L.fn.2.3 fn.2 17 31 5))))))))

  ;; letrec in letrec
  (check-interp
    `(module
      (letrec ([L.fn.1.4
                (lambda (c.4)
                  (let ()
                    (letrec ([L.x.1.5
                              (lambda (c.5 a.1)
                                (let ([x.1 (closure-ref c.5 0)])
                                  (if (unsafe-fx<= a.1 0)
                                    1
                                    (unsafe-fx*
                                    a.1
                                    (closure-call
                                      x.1
                                      x.1
                                      (unsafe-fx- a.1 1))))))])
                      (cletrec ([x.1 (make-closure L.x.1.5 1 x.1)]) x.1))))])
        (cletrec ([fn.1 (make-closure L.fn.1.4 0)])
          (let ([tmp.6 (closure-call fn.1 fn.1)])
            ;; tmp should not be optimized
            (closure-call tmp.6 tmp.6 5))))))

  ;; effects
  (check-interp
    `(module
      (let ([b.1 1]
            [v.1 (unsafe-make-vector 5)])
        (begin
          (unsafe-vector-set! v.1 1 1)
          (letrec ([L.x.1.7
                    (lambda (c.4 a.1)
                      (let ([x.1 (closure-ref c.4 0)]
                            [b.1 (closure-ref c.4 1)])
                        (if (unsafe-fx<= a.1 0)
                            1
                            (unsafe-fx*
                              a.1
                              (closure-call
                                x.1
                                x.1
                                (begin
                                  (unsafe-vector-set!
                                    v.1
                                    1
                                    (unsafe-fx* 2 (unsafe-vector-ref v.1 1)))
                                  (unsafe-fx- a.1 b.1)))))))])
            (cletrec ([x.1 (make-closure L.x.1.7 1 x.1 b.1)])
              (begin
                (unsafe-vector-set! v.1 0 (closure-call x.1 x.1 6))
                (unsafe-fx+
                  (unsafe-vector-ref v.1 1)
                  (unsafe-vector-ref v.1 0)))))))))
  )
